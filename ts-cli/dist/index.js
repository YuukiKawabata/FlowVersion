#!/usr/bin/env node
import{Command as Q}from"commander";import r from"picocolors";import{promises as u}from"fs";import a from"path";import{promises as v}from"fs";import N from"path";import{createHash as Y}from"crypto";import P from"path";function K(t=process.cwd()){return t}function b(t=process.cwd()){return P.join(K(t),".flow")}function I(t=process.cwd()){return P.join(b(t),"objects")}function h(t=process.cwd()){return P.join(b(t),"index.json")}async function G(t=process.cwd()){await v.mkdir(I(t),{recursive:!0})}async function T(t,n=process.cwd()){let o=Buffer.isBuffer(t)?t:Buffer.from(t),i=Y("sha256").update(o).digest("hex"),e=N.join(I(n),i.slice(0,2)),s=N.join(e,i.slice(2));await v.mkdir(e,{recursive:!0});try{await v.access(s)}catch{await v.writeFile(s,o)}return i}async function O(t,n=process.cwd()){let o=N.join(I(n),t.slice(0,2)),i=N.join(o,t.slice(2));return v.readFile(i)}import{promises as J}from"fs";import L from"path";import V from"yaml";function W(t=process.cwd()){return L.join(b(t),"config.yml")}async function E(t=process.cwd()){let n=W(t);try{let o=await J.readFile(n,"utf-8");return V.parse(o)??{}}catch{return{}}}async function R(t,n=process.cwd()){let o=W(n),i=L.dirname(o);await J.mkdir(i,{recursive:!0});let e=new V.Document(t);await J.writeFile(o,e.toString(),"utf-8")}import{promises as $}from"fs";import S from"path";async function F(t,n){try{let i=(await $.readFile(t,"utf-8")).replace(/^\uFEFF/,"");return JSON.parse(i)}catch{try{let i=S.dirname(t),e=S.basename(t),s=new Date().toISOString().replace(/[:.]/g,"-"),c=S.join(i,`${e}.corrupt-${s}.bak`);try{await $.copyFile(t,c)}catch{}}catch{}return n}}async function B(t,n){let o=S.dirname(t);await $.mkdir(o,{recursive:!0});let i=S.join(o,`.${S.basename(t)}.tmp`);try{let e=new Date().toISOString().replace(/[:.]/g,"-");await $.copyFile(t,`${t}.bak-${e}`)}catch{}await $.writeFile(i,JSON.stringify(n,null,2),"utf-8"),await $.rename(i,t)}import{createTwoFilesPatch as X}from"diff";import Z from"fast-glob";function C(t,n=process.cwd()){return a.relative(n,a.isAbsolute(t)?t:a.join(n,t)).split(a.sep).join("/")}async function k(t=h()){return F(t,[])}async function A(t,n=h()){await B(n,t)}var f=new Q;f.name("flow-ts").description("FlowVersion TypeScript CLI (lightweight)").version("0.1.0");f.command("init").description("Initialize a new FlowVersion repo").option("-n, --name <name>","Project name").option("-d, --description <desc>","Project description").action(async t=>{let n=process.cwd(),o=a.join(n,".flow");await u.mkdir(o,{recursive:!0}),await u.mkdir(a.join(o,"objects"),{recursive:!0});let i={name:t.name??a.basename(n),createdAt:new Date().toISOString()};await u.writeFile(a.join(o,"repo.json"),JSON.stringify(i,null,2)),await R({name:t.name??a.basename(n),description:t.description??"",createdAt:new Date().toISOString()}),console.log(r.green(`Initialized FlowVersion repo at ${o}`))});var M=f.command("config").description("Manage repository config");M.command("show").description("Show current configuration (config.yml)").action(async()=>{let t=await E();console.log(JSON.stringify(t,null,2))});M.command("get").argument("<key>").description("Get a config value").action(async t=>{let n=await E();console.log(n?.[t]??"")});M.command("set").argument("<key>").argument("<value>").description("Set a config value").action(async(t,n)=>{let o=await E();o[t]=n,await R(o),console.log(r.green(`Set ${t}`))});f.command("add").argument("<file>").option("-i, --intention <text>","Intention/description").description("Stage file(s); supports glob patterns").action(async(t,n)=>{let o=process.cwd(),i=a.join(o,".flow");await u.mkdir(i,{recursive:!0}),await G();let e=h(),s=await k(e),d=await Z([t],{dot:!0,cwd:o,onlyFiles:!0,followSymbolicLinks:!1});if(d.length===0){console.log(r.yellow(`No files matched: ${t}`));return}let p=0;for(let g of d.map(l=>l.split(a.sep).join("/"))){let l=C(g,o),y=a.join(o,l),j=await u.stat(y),m=await u.readFile(y),w=await T(m),x=n.intention??null,D={path:l,intention:x,sha:w,size:j.size,mtime:j.mtimeMs,addedAt:Date.now()},z=s.findIndex(H=>H.path===l);z>=0?s[z]=D:s.push(D),p++}await A(s,e),console.log(r.cyan(`Added ${p} file(s)`))});f.command("commit").option("-i, --intention <text>").option("-c, --confidence <num>","0..1",t=>Number(t),1).option("--goal <text>","Goal of the change").option("--context <text>","Context for the change").option("--impact <text>","Expected impact").action(async t=>{let n=process.cwd(),o=a.join(n,".flow");await u.mkdir(o,{recursive:!0});let i=a.join(o,"commits.json"),e=h(),s=await k(e);if(s.length===0){console.log(r.yellow("Nothing to commit. Stage changes with `flow add <file>`."));return}let c=Math.random().toString(36).slice(2,10),d={id:c,intention:t.intention??null,confidence:Math.max(0,Math.min(1,Number(t.confidence??1))),timestamp:new Date().toISOString(),goal:t.goal??null,context:t.context??null,impact:t.impact??null,snapshot:s},p=await F(i,[]);p.push(d),await B(i,p),await A([],e),console.log(r.green(`Committed ${c}`))});f.command("status").description("Show staged files and repository status").action(async()=>{let t=h(),n=await k(t);if(n.length===0){console.log("Nothing staged.");return}console.log(r.bold("Staged files:"));for(let o of n){let i=a.join(process.cwd(),o.path),e="staged";try{let s=await u.readFile(i);await T(s)!==o.sha&&(e="modified")}catch{e="deleted"}console.log(` - ${o.path}  ${o.sha?.slice(0,8)??""}  ${o.intention??""}  [${e}]`)}});f.command("unstage").argument("<file>").description("Remove a file from staging area").action(async t=>{let n=h(),o=await k(n),i=C(t),e=o.filter(c=>c.path!==i),s=o.length-e.length;await A(e,n),console.log(s>0?r.yellow(`Unstaged ${i}`):r.dim(`No match: ${i}`))});f.command("reset").description("Clear staging area").action(async()=>{await A([],h()),console.log(r.yellow("Cleared staging area."))});f.command("diff").argument("<file>").description("Show diff between working file and staged version").action(async t=>{let n=await k(h()),o=C(t),i=n.find(g=>g.path===o);if(!i){console.log(r.yellow(`Not staged: ${o}`));return}let e=process.cwd(),s=a.join(e,o),c="";try{c=(await u.readFile(s)).toString("utf8")}catch{c=""}let d=(await O(i.sha)).toString("utf8"),p=X(o+" (WORKTREE)",o+" (STAGED)",c,d,void 0,void 0,{context:3});console.log(p)});f.command("log").description("Show commit log").action(async()=>{let t=a.join(process.cwd(),".flow","commits.json"),n=await F(t,[]);if(n.length===0){console.log("No commits yet.");return}let o=8,i=e=>e>=.8?r.green:e>=.5?r.yellow:r.red;for(let e of n){let s=e.id.slice(0,o),c=i(e.confidence)(`conf=${e.confidence}`),d=e.intention??"";console.log(`${r.bold(s)}  ${e.timestamp}  ${d}  ${c}`)}});function _(t){return r.bold(t)}function U(t,n){let o=t.find(e=>e.id===n);if(o)return{item:o,ambiguous:!1,candidates:[]};let i=t.filter(e=>e.id.startsWith(n));return i.length===1?{item:i[0],ambiguous:!1,candidates:[]}:i.length>1?{item:null,ambiguous:!0,candidates:i}:{item:null,ambiguous:!1,candidates:[]}}f.command("show").argument("<id>","commit id or prefix").argument("[file]","optional file path to show from snapshot").description("Show commit details or file contents from a commit").action(async(t,n)=>{let o=a.join(b(),"commits.json"),i=await F(o,[]);if(i.length===0){console.log("No commits.");return}let e=U(i,t);if(!e.item){if(e.ambiguous){let l=e.candidates.slice(0,5).map(y=>` - ${y.id.slice(0,8)}  ${y.intention??""}`).join(`
`);console.log(r.red("Ambiguous commit id. Be more specific. Candidates:")),l&&console.log(l)}else console.log(r.red("Commit not found."));return}let s=e.item;console.log(`${_(s.id)}  ${s.timestamp}  ${s.intention??""}  (conf=${s.confidence})`),(s.goal||s.context||s.impact)&&(s.goal&&console.log(`  goal: ${s.goal}`),s.context&&console.log(`  context: ${s.context}`),s.impact&&console.log(`  impact: ${s.impact}`));let c=s.snapshot;if(!c||c.length===0){console.log(r.dim("No snapshot stored for this commit."));return}if(!n){for(let l of c)console.log(` - ${l.path}  ${l.sha.slice(0,8)}  ${l.intention??""}`);return}let d=C(n),p=c.find(l=>l.path===d);if(!p){console.log(r.yellow(`File not found in snapshot: ${d}`));return}let g=await O(p.sha);process.stdout.write(g)});f.command("checkout").argument("<id>","commit id or prefix").option("-p, --path <file>","restore a single file from the commit").option("-A, --all","restore all files in the commit").option("-f, --force","overwrite existing files").option("-n, --dry-run","do not write files, only show actions").description("Restore files from a commit snapshot into the working directory").action(async(t,n)=>{let o=a.join(b(),"commits.json"),i=await F(o,[]);if(i.length===0){console.log("No commits.");return}let e=U(i,t);if(!e.item){if(e.ambiguous){let m=e.candidates.slice(0,5).map(w=>` - ${w.id.slice(0,8)}  ${w.intention??""}`).join(`
`);console.log(r.red("Ambiguous commit id. Be more specific. Candidates:")),m&&console.log(m)}else console.log(r.red("Commit not found."));return}let c=e.item.snapshot;if(!c||c.length===0){console.log(r.dim("No snapshot stored for this commit."));return}let d=process.cwd(),p=!!n.force;if(n.path&&n.all){console.log(r.red("Use either --path or --all."));return}let g=[];if(n.path){let m=C(n.path),w=c.find(x=>x.path===m);if(!w){console.log(r.yellow(`File not in commit: ${m}`));return}g=[w]}else if(n.all)g=c;else{console.log(r.yellow("Specify --path <file> or --all"));return}let l=0,y=0,j=[];for(let m of g){let w=m.path.split("/").join(a.sep),x=a.join(d,w);await u.mkdir(a.dirname(x),{recursive:!0});try{if(await u.access(x),!p){y++,j.push({path:m.path,action:"skip-exists"});continue}}catch{}if(!n.dryRun){let D=await O(m.sha);await u.writeFile(x,D)}j.push({path:m.path,action:"write"}),l++}if(n.dryRun){console.log(r.bold("Dry run plan:"));for(let m of j)console.log(` - ${m.action} ${m.path}`)}console.log(r.green(`Restored: ${l}  Skipped: ${y}`))});f.parseAsync(process.argv);
