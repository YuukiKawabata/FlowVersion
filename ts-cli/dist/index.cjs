#!/usr/bin/env node
"use strict";var q=Object.create;var W=Object.defineProperty;var tt=Object.getOwnPropertyDescriptor;var ot=Object.getOwnPropertyNames;var nt=Object.getPrototypeOf,et=Object.prototype.hasOwnProperty;var it=(t,o,n,i)=>{if(o&&typeof o=="object"||typeof o=="function")for(let e of ot(o))!et.call(t,e)&&e!==n&&W(t,e,{get:()=>o[e],enumerable:!(i=tt(o,e))||i.enumerable});return t};var x=(t,o,n)=>(n=t!=null?q(nt(t)):{},it(o||!t||!t.__esModule?W(n,"default",{value:t,enumerable:!0}):n,t));var Y=require("commander"),r=x(require("picocolors"),1),f=require("fs"),a=x(require("path"),1);var v=require("fs"),k=x(require("path"),1),U=require("crypto");var O=x(require("path"),1);function st(t=process.cwd()){return t}function j(t=process.cwd()){return O.default.join(st(t),".flow")}function E(t=process.cwd()){return O.default.join(j(t),"objects")}function h(t=process.cwd()){return O.default.join(j(t),"index.json")}async function H(t=process.cwd()){await v.promises.mkdir(E(t),{recursive:!0})}async function R(t,o=process.cwd()){let n=Buffer.isBuffer(t)?t:Buffer.from(t),i=(0,U.createHash)("sha256").update(n).digest("hex"),e=k.default.join(E(o),i.slice(0,2)),s=k.default.join(e,i.slice(2));await v.promises.mkdir(e,{recursive:!0});try{await v.promises.access(s)}catch{await v.promises.writeFile(s,n)}return i}async function A(t,o=process.cwd()){let n=k.default.join(E(o),t.slice(0,2)),i=k.default.join(n,t.slice(2));return v.promises.readFile(i)}var P=require("fs"),B=x(require("path"),1),M=x(require("yaml"),1);function K(t=process.cwd()){return B.default.join(j(t),"config.yml")}async function T(t=process.cwd()){let o=K(t);try{let n=await P.promises.readFile(o,"utf-8");return M.default.parse(n)??{}}catch{return{}}}async function z(t,o=process.cwd()){let n=K(o),i=B.default.dirname(n);await P.promises.mkdir(i,{recursive:!0});let e=new M.default.Document(t);await P.promises.writeFile(n,e.toString(),"utf-8")}var $=require("fs"),S=x(require("path"),1);async function C(t,o){try{let i=(await $.promises.readFile(t,"utf-8")).replace(/^\uFEFF/,"");return JSON.parse(i)}catch{try{let i=S.default.dirname(t),e=S.default.basename(t),s=new Date().toISOString().replace(/[:.]/g,"-"),c=S.default.join(i,`${e}.corrupt-${s}.bak`);try{await $.promises.copyFile(t,c)}catch{}}catch{}return o}}async function G(t,o){let n=S.default.dirname(t);await $.promises.mkdir(n,{recursive:!0});let i=S.default.join(n,`.${S.default.basename(t)}.tmp`);try{let e=new Date().toISOString().replace(/[:.]/g,"-");await $.promises.copyFile(t,`${t}.bak-${e}`)}catch{}await $.promises.writeFile(i,JSON.stringify(o,null,2),"utf-8"),await $.promises.rename(i,t)}var Q=require("diff"),X=x(require("fast-glob"),1);function D(t,o=process.cwd()){return a.default.relative(o,a.default.isAbsolute(t)?t:a.default.join(o,t)).split(a.default.sep).join("/")}async function I(t=h()){return C(t,[])}async function J(t,o=h()){await G(o,t)}var p=new Y.Command;p.name("flow-ts").description("FlowVersion TypeScript CLI (lightweight)").version("0.1.0");p.command("init").description("Initialize a new FlowVersion repo").option("-n, --name <name>","Project name").option("-d, --description <desc>","Project description").action(async t=>{let o=process.cwd(),n=a.default.join(o,".flow");await f.promises.mkdir(n,{recursive:!0}),await f.promises.mkdir(a.default.join(n,"objects"),{recursive:!0});let i={name:t.name??a.default.basename(o),createdAt:new Date().toISOString()};await f.promises.writeFile(a.default.join(n,"repo.json"),JSON.stringify(i,null,2)),await z({name:t.name??a.default.basename(o),description:t.description??"",createdAt:new Date().toISOString()}),console.log(r.default.green(`Initialized FlowVersion repo at ${n}`))});var L=p.command("config").description("Manage repository config");L.command("show").description("Show current configuration (config.yml)").action(async()=>{let t=await T();console.log(JSON.stringify(t,null,2))});L.command("get").argument("<key>").description("Get a config value").action(async t=>{let o=await T();console.log(o?.[t]??"")});L.command("set").argument("<key>").argument("<value>").description("Set a config value").action(async(t,o)=>{let n=await T();n[t]=o,await z(n),console.log(r.default.green(`Set ${t}`))});p.command("add").argument("<file>").option("-i, --intention <text>","Intention/description").description("Stage file(s); supports glob patterns").action(async(t,o)=>{let n=process.cwd(),i=a.default.join(n,".flow");await f.promises.mkdir(i,{recursive:!0}),await H();let e=h(),s=await I(e),d=await(0,X.default)([t],{dot:!0,cwd:n,onlyFiles:!0,followSymbolicLinks:!1});if(d.length===0){console.log(r.default.yellow(`No files matched: ${t}`));return}let u=0;for(let g of d.map(l=>l.split(a.default.sep).join("/"))){let l=D(g,n),y=a.default.join(n,l),F=await f.promises.stat(y),m=await f.promises.readFile(y),w=await R(m),b=o.intention??null,N={path:l,intention:b,sha:w,size:F.size,mtime:F.mtimeMs,addedAt:Date.now()},V=s.findIndex(_=>_.path===l);V>=0?s[V]=N:s.push(N),u++}await J(s,e),console.log(r.default.cyan(`Added ${u} file(s)`))});p.command("commit").option("-i, --intention <text>").option("-c, --confidence <num>","0..1",t=>Number(t),1).option("--goal <text>","Goal of the change").option("--context <text>","Context for the change").option("--impact <text>","Expected impact").action(async t=>{let o=process.cwd(),n=a.default.join(o,".flow");await f.promises.mkdir(n,{recursive:!0});let i=a.default.join(n,"commits.json"),e=h(),s=await I(e);if(s.length===0){console.log(r.default.yellow("Nothing to commit. Stage changes with `flow add <file>`."));return}let c=Math.random().toString(36).slice(2,10),d={id:c,intention:t.intention??null,confidence:Math.max(0,Math.min(1,Number(t.confidence??1))),timestamp:new Date().toISOString(),goal:t.goal??null,context:t.context??null,impact:t.impact??null,snapshot:s},u=await C(i,[]);u.push(d),await G(i,u),await J([],e),console.log(r.default.green(`Committed ${c}`))});p.command("status").description("Show staged files and repository status").action(async()=>{let t=h(),o=await I(t);if(o.length===0){console.log("Nothing staged.");return}console.log(r.default.bold("Staged files:"));for(let n of o){let i=a.default.join(process.cwd(),n.path),e="staged";try{let s=await f.promises.readFile(i);await R(s)!==n.sha&&(e="modified")}catch{e="deleted"}console.log(` - ${n.path}  ${n.sha?.slice(0,8)??""}  ${n.intention??""}  [${e}]`)}});p.command("unstage").argument("<file>").description("Remove a file from staging area").action(async t=>{let o=h(),n=await I(o),i=D(t),e=n.filter(c=>c.path!==i),s=n.length-e.length;await J(e,o),console.log(s>0?r.default.yellow(`Unstaged ${i}`):r.default.dim(`No match: ${i}`))});p.command("reset").description("Clear staging area").action(async()=>{await J([],h()),console.log(r.default.yellow("Cleared staging area."))});p.command("diff").argument("<file>").description("Show diff between working file and staged version").action(async t=>{let o=await I(h()),n=D(t),i=o.find(g=>g.path===n);if(!i){console.log(r.default.yellow(`Not staged: ${n}`));return}let e=process.cwd(),s=a.default.join(e,n),c="";try{c=(await f.promises.readFile(s)).toString("utf8")}catch{c=""}let d=(await A(i.sha)).toString("utf8"),u=(0,Q.createTwoFilesPatch)(n+" (WORKTREE)",n+" (STAGED)",c,d,void 0,void 0,{context:3});console.log(u)});p.command("log").description("Show commit log").action(async()=>{let t=a.default.join(process.cwd(),".flow","commits.json"),o=await C(t,[]);if(o.length===0){console.log("No commits yet.");return}let n=8,i=e=>e>=.8?r.default.green:e>=.5?r.default.yellow:r.default.red;for(let e of o){let s=e.id.slice(0,n),c=i(e.confidence)(`conf=${e.confidence}`),d=e.intention??"";console.log(`${r.default.bold(s)}  ${e.timestamp}  ${d}  ${c}`)}});function rt(t){return r.default.bold(t)}function Z(t,o){let n=t.find(e=>e.id===o);if(n)return{item:n,ambiguous:!1,candidates:[]};let i=t.filter(e=>e.id.startsWith(o));return i.length===1?{item:i[0],ambiguous:!1,candidates:[]}:i.length>1?{item:null,ambiguous:!0,candidates:i}:{item:null,ambiguous:!1,candidates:[]}}p.command("show").argument("<id>","commit id or prefix").argument("[file]","optional file path to show from snapshot").description("Show commit details or file contents from a commit").action(async(t,o)=>{let n=a.default.join(j(),"commits.json"),i=await C(n,[]);if(i.length===0){console.log("No commits.");return}let e=Z(i,t);if(!e.item){if(e.ambiguous){let l=e.candidates.slice(0,5).map(y=>` - ${y.id.slice(0,8)}  ${y.intention??""}`).join(`
`);console.log(r.default.red("Ambiguous commit id. Be more specific. Candidates:")),l&&console.log(l)}else console.log(r.default.red("Commit not found."));return}let s=e.item;console.log(`${rt(s.id)}  ${s.timestamp}  ${s.intention??""}  (conf=${s.confidence})`),(s.goal||s.context||s.impact)&&(s.goal&&console.log(`  goal: ${s.goal}`),s.context&&console.log(`  context: ${s.context}`),s.impact&&console.log(`  impact: ${s.impact}`));let c=s.snapshot;if(!c||c.length===0){console.log(r.default.dim("No snapshot stored for this commit."));return}if(!o){for(let l of c)console.log(` - ${l.path}  ${l.sha.slice(0,8)}  ${l.intention??""}`);return}let d=D(o),u=c.find(l=>l.path===d);if(!u){console.log(r.default.yellow(`File not found in snapshot: ${d}`));return}let g=await A(u.sha);process.stdout.write(g)});p.command("checkout").argument("<id>","commit id or prefix").option("-p, --path <file>","restore a single file from the commit").option("-A, --all","restore all files in the commit").option("-f, --force","overwrite existing files").option("-n, --dry-run","do not write files, only show actions").description("Restore files from a commit snapshot into the working directory").action(async(t,o)=>{let n=a.default.join(j(),"commits.json"),i=await C(n,[]);if(i.length===0){console.log("No commits.");return}let e=Z(i,t);if(!e.item){if(e.ambiguous){let m=e.candidates.slice(0,5).map(w=>` - ${w.id.slice(0,8)}  ${w.intention??""}`).join(`
`);console.log(r.default.red("Ambiguous commit id. Be more specific. Candidates:")),m&&console.log(m)}else console.log(r.default.red("Commit not found."));return}let c=e.item.snapshot;if(!c||c.length===0){console.log(r.default.dim("No snapshot stored for this commit."));return}let d=process.cwd(),u=!!o.force;if(o.path&&o.all){console.log(r.default.red("Use either --path or --all."));return}let g=[];if(o.path){let m=D(o.path),w=c.find(b=>b.path===m);if(!w){console.log(r.default.yellow(`File not in commit: ${m}`));return}g=[w]}else if(o.all)g=c;else{console.log(r.default.yellow("Specify --path <file> or --all"));return}let l=0,y=0,F=[];for(let m of g){let w=m.path.split("/").join(a.default.sep),b=a.default.join(d,w);await f.promises.mkdir(a.default.dirname(b),{recursive:!0});try{if(await f.promises.access(b),!u){y++,F.push({path:m.path,action:"skip-exists"});continue}}catch{}if(!o.dryRun){let N=await A(m.sha);await f.promises.writeFile(b,N)}F.push({path:m.path,action:"write"}),l++}if(o.dryRun){console.log(r.default.bold("Dry run plan:"));for(let m of F)console.log(` - ${m.action} ${m.path}`)}console.log(r.default.green(`Restored: ${l}  Skipped: ${y}`))});p.parseAsync(process.argv);
